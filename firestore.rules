rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /rooms/{roomId} {
      function isAuthed() {
        return request.auth != null;
      }

      // IMPORTANT: inside nested matches (sessions/*), `resource` refers to the nested doc,
      // not the room doc. Use this helper to check controller against the room.
      function isRoomController() {
        return isAuthed()
          && get(/databases/$(database)/documents/rooms/$(roomId)).data.controllerUid == request.auth.uid;
      }

      // Single-family / simple mode:
      // - Any authenticated user can read rooms (enables join-by-code queries).
      allow read: if isAuthed();

      // Room creator becomes controller.
      allow create: if isAuthed()
        && request.resource.data.controllerUid == request.auth.uid;

      // Room updates:
      // - Controller can update anything.
      // - Any authed user can update `identityMap` (used by join/reconnect flows).
      // - Allow `scoreboard` updates (night aggregation) without requiring controller.
      // - Allow players to claim bingo (update currentSession.status and currentSession.bingoWinnerUid)
      allow update: if isAuthed() && (
        (resource.data.controllerUid == request.auth.uid)
        || request.resource.data.diff(resource.data).changedKeys().hasOnly(['identityMap'])
        || request.resource.data.diff(resource.data).changedKeys().hasOnly(['scoreboard'])
        || request.resource.data.diff(resource.data).changedKeys().hasOnly(['scoreboard', 'identityMap'])
        || (
          // Allow bingo claiming: players can update currentSession when claiming bingo
          // IMPORTANT: keep this narrow: only allow changing the top-level `currentSession` field.
          resource.data.currentSession != null
          && resource.data.currentSession.gameId == 'bingo'
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['currentSession'])
          && request.resource.data.currentSession != null
          && request.resource.data.currentSession.gameId == 'bingo'
          // Player claims are only allowed from in_game -> claiming.
          && resource.data.currentSession.status == 'in_game'
          && request.resource.data.currentSession.status == 'claiming'
          // The last winner must be the caller.
          && request.resource.data.currentSession.bingoLastWinnerUid == request.auth.uid
          // Only allow setting `bingoWinnerUid` on the first claim; after that it must remain unchanged.
          && (
            (
              (resource.data.currentSession.bingoWinnerUid == null || resource.data.currentSession.bingoWinnerUid == '')
              && request.resource.data.currentSession.bingoWinnerUid == request.auth.uid
            )
            || (
              (resource.data.currentSession.bingoWinnerUid != null && resource.data.currentSession.bingoWinnerUid != '')
              && request.resource.data.currentSession.bingoWinnerUid == resource.data.currentSession.bingoWinnerUid
            )
          )
        )
      );

      allow delete: if isAuthed() && resource.data.controllerUid == request.auth.uid;
      
      // Players subcollection
      match /players/{playerId} {
        allow read: if isAuthed();
        
        // Allow create if user is creating their own player doc and can read room
        allow create: if isAuthed() && request.auth.uid == playerId;
        
        // Allow update if user is updating their own player doc or is controller
        // Also allow updates to identity fields (displayName, displayTag, playerIdentityId, playerKey, lastSeenAt)
        allow update: if isAuthed() && (
          request.auth.uid == playerId
          || get(/databases/$(database)/documents/rooms/$(roomId)).data.controllerUid == request.auth.uid
          || (
            // Allow identity field updates for reconnect
            request.resource.data.diff(resource.data).changedKeys().hasOnly([
              'displayName',
              'displayNameNormalized',
              'displayTag',
              'playerIdentityId',
              'playerKey',
              'playerKeyType',
              'lastSeenAt',
              'lastActiveAt'
            ])
          )
        );
        
        // Allow delete if user is deleting their own doc or is controller
        allow delete: if isAuthed() && (
          request.auth.uid == playerId
          || get(/databases/$(database)/documents/rooms/$(roomId)).data.controllerUid == request.auth.uid
        );
      }

      // Optional TV event feed (legacy - kept for backward compatibility)
      match /events/{eventId} {
        allow read: if isAuthed();
        allow create: if isAuthed();
        allow update, delete: if isRoomController();
      }

      // Mini-game sessions (one room -> many sessions)
      match /sessions/{sessionId} {
        allow read: if isAuthed();
        allow create, update, delete: if isRoomController();

        // Selected deck for this session (single doc: selected/selected)
        match /selected/{docId} {
          allow read: if isAuthed();
          allow create, update, delete: if isRoomController();
        }

        // AI-generated content cache (stored per session per game type)
        match /aiContent/{gameType} {
          allow read: if isAuthed();
          allow create, update: if isAuthed(); // Allow any authenticated user to generate/cache AI content
          allow delete: if isRoomController();
        }

        // Per-player answer doc (doc id = uid)
        match /answers/{uid} {
          allow read: if isAuthed();
          allow create, update: if isAuthed() && (
            request.auth.uid == uid
            || isRoomController()
          );
          allow delete: if isRoomController();
        }

        // Per-session scores (controller-owned, but players can update their own score)
        match /scores/{uid} {
          allow read: if isAuthed();
          allow create, update: if isAuthed() && (
            isRoomController()
            || request.auth.uid == uid  // Players can update their own score
          );
          allow delete: if isRoomController();
        }

        // Pictionary session realtime docs + subcollections
        match /pictionary/{docId} {
          allow read: if isAuthed();
          // Allow any authed user to write the live drawing doc (drawer phone),
          // but keep it narrow to expected keys.
          allow create: if isAuthed() && docId == 'live'
            && request.resource.data.keys().hasOnly(['round', 'seq', 'events', 'checkpoint', 'updatedAt']);
          allow update: if isAuthed() && docId == 'live'
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(['round', 'seq', 'events', 'checkpoint', 'updatedAt']);
          allow delete: if isRoomController();

        // Pictionary guesses live under the fixed `live` doc:
        // rooms/{roomId}/sessions/{sessionId}/pictionary/live/guesses/{guessId}
          match /guesses/{guessId} {
            allow read: if isAuthed();
            allow create: if isAuthed() && docId == 'live';
            allow update, delete: if isRoomController();
          }
        }

        // Bingo cards (one per player)
        match /cards/{uid} {
          allow read: if isAuthed();
          allow create, update: if isAuthed() && (
            request.auth.uid == uid
            || isRoomController()
          );
          allow delete: if isRoomController();
        }
      }
    }

    // Optional event/group collections (kept permissive for single-family mode).
    // If you aren't using events, you can delete these matches entirely.
    match /events/{eventId} {
      function isAuthed() { return request.auth != null; }
      allow read, write: if isAuthed();

      match /{document=**} {
        allow read, write: if isAuthed();
      }
    }

    match /groups/{groupId} {
      function isAuthed() { return request.auth != null; }
      allow read, write: if isAuthed();

      match /{document=**} {
        allow read, write: if isAuthed();
      }
    }

  // Tradition Wheels
  match /traditionWheels/{wheelId} {
    function isAuthed() {
      return request.auth != null;
    }

    function isController() {
      return isAuthed() && resource.data.controllerUid == request.auth.uid;
    }

    allow read: if isAuthed();
    allow create: if isAuthed() && request.resource.data.controllerUid == request.auth.uid;
    allow update: if isAuthed() && (
      isController()
      || (
        // Allow any authed user to update usedIds and lastSpunAt (for spinning)
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['usedIds', 'lastSpunAt'])
      )
    );
    allow delete: if isController();
  }

  // User profiles - users can read and write their own profile
  match /users/{userId} {
    function isAuthed() {
      return request.auth != null;
    }

    allow read: if isAuthed() && request.auth.uid == userId;
    allow create: if isAuthed() && request.auth.uid == userId;
    allow update: if isAuthed() && request.auth.uid == userId;
    allow delete: if isAuthed() && request.auth.uid == userId;
  }
  }
}
